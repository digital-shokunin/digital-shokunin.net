<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Digital Shokunin</title><link href="http://digital-shokunin.net/" rel="alternate"></link><link href="http://digital-shokunin.net/feeds/SysAdmin/DevOps,%20Hacking.atom.xml" rel="self"></link><id>http://digital-shokunin.net/</id><updated>2013-11-07T21:00:00-05:00</updated><entry><title>Reverse XOR'ing Websphere Passwords</title><link href="http://digital-shokunin.net/websphere-xor-password.html" rel="alternate"></link><updated>2013-11-07T21:00:00-05:00</updated><author><name>David Mitchell</name></author><id>tag:digital-shokunin.net,2013-11-07:websphere-xor-password.html</id><summary type="html">&lt;p&gt;Some of the lessons I've learned from the &lt;a href="http://www.matasano.com/articles/crypto-challenges/"&gt;Matasano Crypto Challenge&lt;/a&gt;
has already had unexpected practical application for a common issue I 
encounter at work. Sometimes, people forget things, don't document things
especially in dev environments (hopefully not so much in production), one
of those things is passwords, passwords for database accounts, or for an
account that has some authorization the application needs. If a dev forgets
a password or can't find where it was documented, it's many times better
to just recover the password, rather then reset the password, especially
if the account is used by the application in local dev environments, etc.&lt;/p&gt;
&lt;p&gt;There are also sites that will reverse it for you, but why use a website 
when you can use a jython/python script. You can also  use the 
com.ibm.ws.security.util.PasswordDecoder method from within wsadmin to 
accomplish the same task as well. The one thing I haven't found is a 
Python script example on how to do this, so I decided to write my own 
simple script module that can decode (or encode) a password that can 
execute in jython (wsadmin) or plain Python. &lt;/p&gt;
&lt;p&gt;WebSphere stores most of the account information used by applications to 
connect to resources as authentication aliases. The authentication aliases 
are stored by WebSphere in the security.xml file for the cell in a network
deployment setup, of which the password is stored as an xor string.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;Lz4sLCgwLTs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, xor'ing passwords is not a very strong hash method for securing a 
password, as we'll soon explore, wspecially when xor'ing 
against a single character, which is what WebSphere does. This exacerbates
the need for good file system security on your websphere installation so 
that not just anyone can view your security.xml file. I could have 
tried xor'ing against various single characters to crack it in seconds, 
but there are already multiple other articles and posts out there on how 
to reverse xor the WebSphere, checking a couple of results from Google
you learn passwords are xor'ed against the underscore '_' character. &lt;/p&gt;
&lt;p&gt;First, the password hash is base64 encoded, so you have to decode it using
the binascii module (base64 library wasn't supported in wsadmin). Well, 
first is actually removing the {xor} prefix, but that's a minor detail.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="n"&gt;xor_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;{xor}Lz4sLCgwLTs=&amp;quot;&lt;/span&gt;
 &lt;span class="n"&gt;xor_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xor_str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="n"&gt;value1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;binascii&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a2b_base64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xor_str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then you create another string of underscores that is the same length as
the string resulting from the base64 decode.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="n"&gt;value2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now you have two strings of equal length, one being underscores, now you 
just xorsum the two strings. The easiest way I've found is to just do it 
character by character rather then whole strings at a time.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
 &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
     &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, your password variable will contain the decoded password. Very 
simple.&lt;/p&gt;
&lt;p&gt;If you need something like this or want to see how I pull it all together,
I've got the full code anyone can use/implement, also with the encode 
functions in a &lt;a href="https://github.com/digital-shokunin/was_xor_decode"&gt;Github repo&lt;/a&gt;.&lt;/p&gt;</summary><category term="ibm"></category><category term="websphere"></category><category term="crypto"></category><category term="python"></category><category term="security"></category></entry></feed>